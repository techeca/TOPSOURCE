/* Generated by Together */

#include "Stdafx.h"
#include "SubMap.h"
#include "MoveAble.h"
#include "GameApp.h"
#include "CommFunc.h"
#include "Parser.h"

_DBC_USING

const char* GetResPath(const char* pszRes);

SubMap::SubMap()
	: m_pCEyeshotCell(0), m_pCStateCell(0), m_bIsRun(false) {
	m_sCopyNO = 0;
	m_timeSpecialRun.Begin(300 * 1000); //5*60*1000
}

SubMap::~SubMap() {
	/*	for (short i = 0; i < GetEyeshotCellLin(); i++)
	{
		for (short j = 0; j < GetEyeshotCellCol(); j++)
		{
			delete [] m_pCEyeshotCell[i][j].m_pCStateCell;
		}
		delete [] m_pCEyeshotCell[i];
	}
	delete [] m_pCEyeshotCell;
	m_pCEyeshotCell = 0;

	for (short i = 0; i < GetStateCellLin(); i++)
		delete [] m_pCStateCell[i];
	delete [] m_pCStateCell;
	m_pCStateCell = 0;
*/
}

bool SubMap::Init(CMapRes* pCMapRes, dbc::Short sCopyNO) {
	T_B
		m_pCMapRes = pCMapRes;
	m_pCBaseRange = 0;

	// 状态单元
	m_pCStateCell = new CStateCell**[GetStateCellLin()];
	if (!m_pCStateCell)
		//THROW_EXCP(excpMem,"地图状态单元对象构造过程中分配内存失败");
		THROW_EXCP(excpMem, RES_STRING(GM_SUBMAP_CPP_00001));
	for (short i = 0; i < GetStateCellLin(); i++) {
		m_pCStateCell[i] = new CStateCell*[GetStateCellCol()];
		if (!m_pCStateCell[i])
			//THROW_EXCP(excpMem,"地图状态单元对象构造过程中分配内存失败");
			THROW_EXCP(excpMem, RES_STRING(GM_SUBMAP_CPP_00001));
		for (short j = 0; j < GetStateCellCol(); j++)
			m_pCStateCell[i][j] = 0;
	}
	// 视野单元
	m_pCEyeshotCell = new CEyeshotCell*[GetEyeshotCellLin()];
	if (!m_pCEyeshotCell)
		//THROW_EXCP(excpMem,"地图视野单元对象构造过程中分配内存失败");
		THROW_EXCP(excpMem, RES_STRING(GM_SUBMAP_CPP_00002));
	short sECellSX, sECellEX, sECellSY, sECellEY;
	short sSCellNum;
	for (short i = 0; i < GetEyeshotCellLin(); i++) {
		m_pCEyeshotCell[i] = new CEyeshotCell[GetEyeshotCellCol()];
		if (!m_pCEyeshotCell[i])
			//THROW_EXCP(excpMem,"地图视野单元对象构造过程中分配内存失败");
			THROW_EXCP(excpMem, RES_STRING(GM_SUBMAP_CPP_00002));
		// 初始化
		for (short j = 0; j < GetEyeshotCellCol(); j++) {
			m_pCEyeshotCell[i][j].m_sPosX = j;
			m_pCEyeshotCell[i][j].m_sPosY = i;

			sECellSX = j * GetEyeshotCellWidth() / GetStateCellWidth();
			sECellEX = (j * GetEyeshotCellWidth() + GetEyeshotCellWidth() - 1) / GetStateCellWidth();
			sECellSY = i * GetEyeshotCellHeight() / GetStateCellHeight();
			sECellEY = (i * GetEyeshotCellHeight() + GetEyeshotCellHeight() - 1) / GetStateCellHeight();
			m_pCEyeshotCell[i][j].m_sStateCellNum = (sECellEX - sECellSX + 1) * (sECellEY - sECellSY + 1);
			m_pCEyeshotCell[i][j].m_pCStateCell = new CStateCell**[m_pCEyeshotCell[i][j].m_sStateCellNum];
			sSCellNum = 0;
			for (short m = sECellSY; m <= sECellEY; m++)
				for (short n = sECellSX; n <= sECellEX; n++)
					m_pCEyeshotCell[i][j].m_pCStateCell[sSCellNum++] = &m_pCStateCell[m][n];
		}
	}

	// 装载附加资源
	m_pCMapRes->m_pCMonsterSpawn->Load(this);		  // resok
	m_pCMapRes->m_pCMapSwitchEntitySpawn->Load(this); // resok
	LoadNpc();										  // 注意NPC应该最后装载，必须在它装载前先初始化一些NPC需要的其他信息,resok
	LoadEventEntity();								  // 装载事件实体信息,resok

	luaL_dofile(g_pLuaState, GetResPath(m_pCMapRes->m_szMonsterCofFile)); //resok

	m_bIsRun = false;
	m_sCopyNO = sCopyNO;
	m_timeScriptRun.Begin(1000);
	m_lPlayerNum = 0;
	//	m_lActivePlayerNum = 0;
	memset(m_lInfoParam, 0, sizeof(dbc::Long) * defMAPCOPY_INFO_PARAM_NUM);

	return true;
	T_E
}

//=============================================================================
// lFromEntityID 道具从该角色身上抛出来
// lProtChaID，lProtTime 对该角色保护时间，若lProtChaID为0，则不做保护.若lProtTime为0；则采用系统默认保护时间，为-1，则永久保护
// lOnTick 道具存在时间，为0，则采用系统默认保护时间；为-1，则永久存在
// usEventType，pEventRec 道具所带的事件
//=============================================================================
CItem* SubMap::ItemSpawn(const SItemGrid* pItemInfo, Long lPosX, Long lPosY, Char chSpawnType,
						 Long lFromEntityID, Long lProtChaID, Long lProtChaHandle, Long lProtTime, Long lOnTick,
						 CEvent* pCEvent) {
	T_B
		CItem* pCItem;
	CItemRecord* pCItemRec;

	pCItemRec = GetItemRecordInfo(pItemInfo->sID);
	if (!pCItemRec)
		return 0;
	pCItem = g_pGameApp->GetNewItem();
	if (!pCItem)
		return 0;
	memcpy(&pCItem->m_SGridContent, pItemInfo, sizeof(SItemGrid));
	//if (pCItemRec->chExclusiveID) // 需要保存到数据库，但当前的数据库ID是0，则需要分配
	//{
	//	pItemInfo->SetDBParam(-1, 0);
	//}
	//else
	//	pItemInfo->SetDBParam(-1, 0);
	pCItem->m_pCItemRecord = pCItemRec;
	if (pCEvent)
		pCItem->SetEvent(*pCEvent);
	pCItem->SetName(pCItemRec->szName);
	pCItem->SetCat(pItemInfo->sID);
	pCItem->m_ID = g_pGameApp->m_Ident.GetID();
	pCItem->SetSpawnType(chSpawnType);
	pCItem->SetFromID(lFromEntityID);
	Square SShape = {{lPosX, lPosY}, 0};
	pCItem->SetAngle(rand() / 360);
	pCItem->SetEyeshotAbility(false);
	if (!Enter(&SShape, pCItem)) {
		pCItem->Free();
		return 0;
	}
	pCItem->SetSpawnType(enumITEM_APPE_NATURAL);
	pCItem->SetProtCha(lProtChaID, lProtChaHandle);
	if (lProtTime == -1)
		pCItem->SetProtOnTick(0);
	else if (lProtTime > 0)
		pCItem->SetProtOnTick(lProtTime);
	if (lOnTick == -1)
		pCItem->SetOnTick(0);
	if (lOnTick > 0)
		pCItem->SetOnTick(lOnTick);

	Char szLogName[defLOG_NAME_LEN] = "";
	sprintf(szLogName, "%s+%u", pCItem->GetName(), pCItem->GetID());
	pCItem->m_CLog.SetLogName(szLogName);
	pCItem->m_CLog.SetEnable(g_bLogEntity);

	return pCItem;
	T_E
}

//=============================================================================
// chCtrlType 角色控制类型，参考CompCommand.h EChaCtrlType
//=============================================================================
CCharacter* SubMap::ChaSpawn(Long lChaInfoID, Char chCtrlType, Short sAngle, Point* pSPos, bool bEyeshotAbility, dbc::cChar* cszChaName, const long clSearchRadius) {
	T_B
		CCharacter* pCCha;
	CChaRecord* pCChaRecord;

	if (!IsValidPos(pSPos->x, pSPos->y))
		return 0;

	pCChaRecord = GetChaRecordInfo(lChaInfoID);
	if (pCChaRecord == NULL)
		return 0;
	pCCha = g_pGameApp->GetNewCharacter();
	if (!pCCha)
		return 0;
	pCCha->m_CChaAttr.Init(lChaInfoID);
	if (chCtrlType == enumCHACTRL_NONE)
		chCtrlType = pCChaRecord->chCtrlType;
	pCCha->setAttr(ATTR_CHATYPE, chCtrlType);
	pCCha->m_pCChaRecord = pCChaRecord;
	pCCha->SetCat((short)(pCCha->m_pCChaRecord->lID));
	pCCha->SetID(g_pGameApp->m_Ident.GetID());
	pCCha->m_AIType = (BYTE)(pCChaRecord->lAiNo);
	pCCha->m_sChaseRange = (short)(pCChaRecord->lCDis);
	pCCha->SetAngle(sAngle);
	Square SShape = {*pSPos, pCCha->m_pCChaRecord->sRadii};
	if (!cszChaName)
		strcpy(pCCha->m_name, pCCha->m_pCChaRecord->szName);
	else
		strcpy(pCCha->m_name, cszChaName);
	pCCha->SetEyeshotAbility(bEyeshotAbility);
	if (pCChaRecord->sDormancy > 0)
		pCCha->SetExistState(enumEXISTS_SLEEPING);
	if (!Enter(&SShape, pCCha, clSearchRadius)) {
		pCCha->Free();
		return 0;
	}
	Circle l_STerritory = {*pSPos, 500};
	pCCha->SetTerritory(l_STerritory);

	// 加入技能
	pCCha->EnrichSkillBag();

	Char szLogName[defLOG_NAME_LEN] = "";
	sprintf(szLogName, "Cha-%s+%u", pCCha->GetName(), pCCha->GetID());
	pCCha->m_CLog.SetLogName(szLogName);
	pCCha->m_CLog.SetEnable(g_bLogEntity);

	// pCCha->ResetLifeTime(5000);

	return pCCha;
	T_E
}

// 通告副本内的所有玩家
void SubMap::Notice(const char* szString) {
	T_B
		WPACKET WtPk = GETWPACKET();
	WRITE_CMD(WtPk, CMD_MC_SYSINFO);
	WRITE_STRING(WtPk, szString);

	CPlayer *pHeadPlayer = 0, *pLastPlayer = 0;
	CEyeshotCell* pCEyeCell;
	CCharacter* pCCha;
	Long lChaCount, lChaNum;
	m_CEyeshotCellL.BeginGet();
	while (pCEyeCell = m_CEyeshotCellL.GetNext()) {
		lChaCount = 0;
		lChaNum = pCEyeCell->GetChaNum();
		pCCha = pCEyeCell->m_pCChaL;
		while (pCCha) {
			if (++lChaCount > lChaNum) {
				//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				LG("eyeshot activation error", "eyeshot cell[%d,%d]fact entity nubmer%d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				break;
			}

			if (pCCha->IsPlayerFocusCha()) {
				if (!pHeadPlayer) {
					pHeadPlayer = pCCha->GetPlayer();
					pLastPlayer = pHeadPlayer;
				} else {
					pLastPlayer->GetNextPlayer() = pCCha->GetPlayer();
					pLastPlayer = (CPlayer*)pLastPlayer->GetNextPlayer();
				}

				if (!pCCha->GetSubMap())
					//LG("视野激活错误", "在进行地图通告时玩家 %s(%s)[%d,%d] 的地图为空\n",
					LG("eyeshot activation error", "in the wind map notify character %s(%s)[%d,%d] 's map is empty\n",
					   pCCha->GetLogName(), pCCha->GetPlyCtrlCha()->GetLogName(), pCCha->GetPos().x, pCCha->GetPos().y);
			}

			if (pCCha->m_pCEyeshotCellNext)
				pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
			else
				pCCha = 0;
		}
	}

	if (pLastPlayer)
		pLastPlayer->GetNextPlayer() = NULL;
	SENDTOCLIENT(WtPk, pHeadPlayer);
	T_E
}

dbc::Long SubMap::CountEyeshotPlyActiveNum(dbc::Long lCellX, dbc::Long lCellY) {
	T_B
		Long lActNum = 0;

	CCharacter* pCCha;
	Long lChaCount = 0, lChaNum;
	pCCha = m_pCEyeshotCell[lCellY][lCellX].m_pCChaL;
	lChaNum = m_pCEyeshotCell[lCellY][lCellX].GetChaNum();
	while (pCCha) {
		if (++lChaCount > lChaNum) {
			//LG("视野激活错误", "计算视野单元[%d,%d]的激活角色数时，实际角色数 %d\n", lCellX, lCellY, lChaNum);
			LG("eyeshot activation error", "account eyeshot cell [%d,%d]'s activation character number，practice character number%d\n", lCellX, lCellY, lChaNum);
			break;
		}

		if (pCCha->IsPlayerCha()) {
			if (pCCha->GetEyeshotAbility())
				lActNum++;
		}

		if (pCCha->m_pCEyeshotCellNext)
			pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
		else
			pCCha = 0;
	}

	return lActNum;
	T_E
}

// 检测位置是否可以通过
bool SubMap::IsMoveAble(Entity* pCEnt, Long lPosX, Long lPosY) {
	T_B
		CFightAble* pCCha = 0;
	if (!pCEnt || !(pCCha = pCEnt->IsFightAble()))
		return false;
	return g_IsMoveAble((char)pCCha->m_CChaAttr.GetAttr(ATTR_CHATYPE), pCCha->m_pCChaRecord->chTerritory, pCEnt->GetAreaAttr()); //存在障碍
	T_E
}

BOOL SubMap::LoadEventEntity() {
	T_B
		g_pScriptMap = this;
	char szMapEntity[256];
	sprintf(szMapEntity, "%s\\%s%s", GetName(), GetName(), "entity.lua");
	ReloadEntity(GetResPath(szMapEntity));
	return TRUE;
	T_E
}

BOOL SubMap::LoadNpc() {
	T_B if (m_pCMapRes->m_pNpcSpawn->Load(*this) == -1) {
		//THROW_EXCP( excpMem, "初始化地图NPC出生信息错误!" );
		THROW_EXCP(excpMem, RES_STRING(GM_SUBMAP_CPP_00003));
		return FALSE;
	}

	return TRUE;
	T_E
}

CNpcRecord* SubMap::GetNpcInfo(USHORT sNpcID) {
	if (m_pCMapRes->m_pNpcSpawn) {
		return m_pCMapRes->m_pNpcSpawn->GetNpcInfo(sNpcID);
	}
	return NULL;
}

// 加入视野单元
void SubMap::Add(Entity* pCEnt) {
	T_B
		CCharacter* pCCha = pCEnt->IsCharacter();
	CItem* pCItem;
	Point l_pt = pCEnt->GetPos();
	Rect l_rect = GetEyeshot(l_pt);

	if (pCEnt->m_pCEyeshotHost) {
		//LG("地图角色操作错误", "（切换）地图 %s 向视野单元[%d, %d]增加实体 %s 时，发现其没有脱离先前的视野单元[%d, %d]\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
		LG("map character operator error", "(switch) map %s to eyeshot cell [%d, %d]add entity %s ，find it is not break away foregone manage cell[%d, %d]\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
		return;
	}
	pCEnt->m_pCEyeshotHost = &m_pCEyeshotCell[l_pt.y][l_pt.x];

	if (pCCha) {
		if (pCCha->IsPlayerCha()) {
			pCCha->GetPlayer()->RefreshMapMask(GetName(), pCCha->GetPos().x / 100, pCCha->GetPos().y / 100);
			pCCha->Cmd_SetInGymkhana(CanPK());
		}

		if (pCCha->IsPlayerOwnCha()) {
			m_lPlayerNum++;
			//			m_lActivePlayerNum++;
		}
	}

	if (pCCha) {
		m_pCEyeshotCell[l_pt.y][l_pt.x].AddEntity(pCCha);

		Long l_radius = pCEnt->GetRadius();
		l_pt = pCEnt->GetPos();
		Rect l_range = GetHoldStateCell(l_pt, l_radius);
		for (long i = l_range.ltop.y; i <= l_range.rbtm.y; i++)
			for (long j = l_range.ltop.x; j <= l_range.rbtm.x; j++) {
				if (i != l_pt.y || j != l_pt.x) {
					//StateCellAddCha(j, i, pCCha, false);
				} else
					StateCellAddCha(j, i, pCCha, true);
			}
	} else if (pCItem = pCEnt->IsItem()) {
		m_pCEyeshotCell[l_pt.y][l_pt.x].AddEntity(pCItem);
	}

	if (pCCha) {
		pCCha->EntryMapUnit(GetMapID(), WORD(l_pt.x), WORD(l_pt.y));
	}
	T_E
}

void SubMap::Delete(Entity* pCEnt) {
	T_B
		CCharacter* pCCha = pCEnt->IsCharacter();
	Point l_pt = pCEnt->GetPos();
	//const Rect	&m_area = GetRange();
	//if (l_pt.x < m_area.ltop.x || l_pt.x >= m_area.rbtm.x || l_pt.y < m_area.ltop.y || l_pt.y >= m_area.rbtm.y)
	//{
	//	LG("地图角色操作错误", "（切换）从地图 %s 删除实体 %s 时，发现该实体的位置[%d, %d]非法\n", GetName(), pCEnt->GetLogName(), l_pt.x, l_pt.y);
	//	return;
	//}
	Rect l_rect = GetEyeshot(l_pt);

	if (!pCEnt->m_pCEyeshotHost) {
		//LG("地图角色操作错误", "（切换）地图 %s 从视野单元[%d, %d]删除实体 %s 时，发现不在视野单元中\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName());
		LG("map character operator error", "(switch)map %s from eyeshot[%d, %d] delete entity %s ，find it isn't in eyeshot cell.\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName());
		return;
	}
	if (pCEnt->m_pCEyeshotHost != &m_pCEyeshotCell[l_pt.y][l_pt.x]) {
		//LG("地图角色操作错误", "（切换）地图 %s 从视野单元[%d, %d]删除实体 %s 时，发现其与记录视野单元[%d, %d]不符\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
		LG("map character operatot error", "(switch)map %s from eyeshot[%d, %d]delete entity %s，find it isn't agree with log eyeshot cell[%d, %d].\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
		return;
	}
	pCEnt->m_pCEyeshotHost = 0;

	if (pCCha) {
		pCCha->Cmd_SetInGymkhana(false);

		if (pCCha->IsPlayerOwnCha()) {
			m_lPlayerNum--;
			//if(pCCha->IsLiveing())
			//	m_lActivePlayerNum--;
		}
	}

	m_pCEyeshotCell[l_pt.y][l_pt.x].DelEntity(pCEnt);
	CStateCellNode* pCNode = pCEnt->m_pCStateCellHead;
	if (pCCha) {
		while (pCNode) {
			StateCellDelCha(pCNode->m_pCStateCell->m_sPosX, pCNode->m_pCStateCell->m_sPosY, pCNode->m_pCChaNode);
			pCNode = pCNode->m_pCNext;
		}
	}
	T_E
}

// 脱离原状态单元，加入新的状态单元
void SubMap::MoveInStateCell(CCharacter* pCCha, const Point& SSrcPos, const Point& STarPos) {
	T_B
		Point l_src = SSrcPos;
	Point l_dst = STarPos;
	Long lRadius = pCCha->GetRadius();
	const Rect l_srcTerr = GetHoldStateCell(l_src, lRadius);
	const Rect l_dstTerr = GetHoldStateCell(l_dst, lRadius);

	if (l_src == l_dst)
		return;

	Long x, y;
	// 从源范围删除
	CStateCellNode* pCNode = pCCha->m_pCStateCellHead;
	if (pCCha) {
		while (pCNode) {
			StateCellDelCha(pCNode->m_pCStateCell->m_sPosX, pCNode->m_pCStateCell->m_sPosY, pCNode->m_pCChaNode);
			pCNode = pCNode->m_pCNext;
		}
	}
	// 向目标范围添加
	for (y = l_dstTerr.ltop.y; y <= l_dstTerr.rbtm.y; y++) {
		for (x = l_dstTerr.ltop.x; x <= l_dstTerr.rbtm.x; x++) {
			if (y != l_dst.y || x != l_dst.x) {
				//StateCellAddCha(x, y, pCCha, false); // 加入到其他管理单元
			} else
				StateCellAddCha(x, y, pCCha, true); // 加入到中心管理单元
		}
	}
	T_E
}

void SubMap::MoveInMapMask(CCharacter* pCCha, const Point& SSrcPos, const Point& STarPos) {
	T_B if (!pCCha->IsPlayerCha()) return;
	Point l_src, l_dst;

	long lStep = 4 * 100;
	l_src.x = SSrcPos.x / lStep;
	l_src.y = SSrcPos.y / lStep;
	l_dst.x = STarPos.x / lStep;
	l_dst.y = STarPos.y / lStep;
	if (l_src != l_dst)
		pCCha->GetPlayer()->RefreshMapMask(GetName(), STarPos.x / 100, STarPos.y / 100);
	T_E
}

//void SubMap::Move(Entity* pCEnt, Point STarPos, Char chStep)
//{
//	Point	l_src = pCEnt->GetPos();
//	Point	l_dst = STarPos;
//	Long	lRadius = pCEnt->GetRadius();
//	const Rect l_srcTerr = GetTerritory(l_src, lRadius);
//	const Rect l_dstTerr = GetTerritory(l_dst, lRadius);
//
//	Long		x, y;
//	if (chStep == 1) // 从源范围删除
//	{
//		//// log
//		//if (!strcmp("tty", pCEnt->GetName()))
//		//{
//		//	char	szPrint[512] = "";
//		//	LG("移动轨迹", "源  ：[%d,%d]--[%d,%d]，[%d,%d].\n",
//		//		l_srcTerr.ltop.x, l_srcTerr.ltop.y, l_srcTerr.rbtm.x, l_srcTerr.rbtm.y, l_src.x, l_src.y);
//		//	LG("移动轨迹", "目标：[%d,%d]--[%d,%d]，[%d,%d].\n",
//		//		l_dstTerr.ltop.x, l_dstTerr.ltop.y, l_dstTerr.rbtm.x, l_dstTerr.rbtm.y, l_dst.x, l_dst.y);
//
//		//	CMgrNode	*pCNode = pCEnt->m_pCMgrNodeHead;
//		//	while (pCNode)
//		//	{
//		//		sprintf(szPrint + strlen(szPrint), "[%d,%d],", pCNode->m_pCMgrUnit->m_sPosX, pCNode->m_pCMgrUnit->m_sPosY);
//		//		pCNode = pCNode->m_pCNext;
//		//	}
//		//	LG("移动轨迹", "角色占用的单元：%s.\n", szPrint);
//		//}
//		////
//
//		CMgrNode	*pCNode = pCEnt->m_pCMgrNodeHead, *pCTempNode;
//		if (pCNode) // 首节点
//		{
//			pCTempNode = pCNode->m_pCNext;
//
//			x = pCNode->m_pCMgrUnit->m_sPosX;
//			y = pCNode->m_pCMgrUnit->m_sPosY;
//			if (x < l_dstTerr.ltop.x || x > l_dstTerr.rbtm.x
//				|| y < l_dstTerr.ltop.y || y > l_dstTerr.rbtm.y) // 不在目标范围内
//				pCNode->m_pCMgrUnit->DelEntity(pCNode->m_pCEntityNode);
//			else
//			{
//				if (l_src != l_dst) // 原来是中心，现在不是
//					m_pCMgrUnit[y][x]->SetEntityIn(pCNode->m_pCEntityNode, false);
//			}
//
//			pCNode = pCTempNode;
//		}
//		while (pCNode)
//		{
//			pCTempNode = pCNode->m_pCNext;
//
//			x = pCNode->m_pCMgrUnit->m_sPosX;
//			y = pCNode->m_pCMgrUnit->m_sPosY;
//			if (x < l_dstTerr.ltop.x || x > l_dstTerr.rbtm.x
//				|| y < l_dstTerr.ltop.y || y > l_dstTerr.rbtm.y) // 不在目标范围内
//				pCNode->m_pCMgrUnit->DelEntity(pCNode->m_pCEntityNode);
//			else
//			{
//				if (l_src != l_dst)
//				{
//					if (l_dst.x == x && l_dst.y == y) // 原来不是中心，现在是
//						m_pCMgrUnit[y][x]->SetEntityIn(pCNode->m_pCEntityNode);
//				}
//			}
//
//			pCNode = pCTempNode;
//		}
//
//		//// log
//		//if (!strcmp("tty", pCEnt->GetName()))
//		//{
//		//	char	szPrint[512] = "";
//		//	CMgrNode	*pCNode = pCEnt->m_pCMgrNodeHead;
//		//	while (pCNode)
//		//	{
//		//		sprintf(szPrint + strlen(szPrint), "[%d,%d],", pCNode->m_pCMgrUnit->m_sPosX, pCNode->m_pCMgrUnit->m_sPosY);
//		//		pCNode = pCNode->m_pCNext;
//		//	}
//		//	LG("移动轨迹", "从源删除后，角色占用的单元：%s.\n", szPrint);
//
//		//	LG("移动轨迹", "源范围被删除后，拥有的角色：\n");
//		//	for (y = l_srcTerr.ltop.y; y <= l_srcTerr.rbtm.y; y++)
//		//		for (x = l_srcTerr.ltop.x; x <= l_srcTerr.rbtm.x; x++)
//		//		{
//		//			szPrint[0] = '\0';
//		//			CEntityListNode	*pCNode = m_pCMgrUnit[y][x]->m_pCChaIn;
//		//			while (pCNode)
//		//			{
//		//				sprintf(szPrint + strlen(szPrint), "%s,", pCNode->m_pCEntity->m_CLog.GetLogName());
//		//				pCNode = pCNode->m_pCNext;
//		//			}
//		//			LG("移动轨迹", "\t中心链[%d,%d]：%s\n", x, y, szPrint);
//		//			szPrint[0] = '\0';
//		//			pCNode = m_pCMgrUnit[y][x]->m_pCChaCross;
//		//			while (pCNode)
//		//			{
//		//				sprintf(szPrint + strlen(szPrint), "%s,", pCNode->m_pCEntity->m_CLog.GetLogName());
//		//				pCNode = pCNode->m_pCNext;
//		//			}
//		//			LG("移动轨迹", "\t交叉链[%d,%d]：%s\n", x, y, szPrint);
//		//		}
//		//}
//		////
//	}
//	else if (chStep == 2) // 向目标范围添加
//	{
//		pCEnt->SetPos(STarPos);
//		if (l_src != l_dst)
//			pCEnt->RefreshArea();
//		for (y = l_dstTerr.ltop.y; y <= l_dstTerr.rbtm.y; y++)
//		{
//			for (x = l_dstTerr.ltop.x; x <= l_dstTerr.rbtm.x; x++)
//			{
//				if (x < l_srcTerr.ltop.x || x > l_srcTerr.rbtm.x
//					|| y < l_srcTerr.ltop.y || y > l_srcTerr.rbtm.y) // 不在源范围内
//				{
//					if (y != l_dst.y || x != l_dst.x)
//						MgrUnitAddEntity(x, y, pCEnt, def_MGRUNIT_ENTITY_TYPE_CHACROSS); // 加入到其他管理单元
//					else
//						MgrUnitAddEntity(x, y, pCEnt, def_MGRUNIT_ENTITY_TYPE_CHAIN); // 加入到中心管理单元
//				}
//			}
//		}
//
//		//// log
//		//if (!strcmp("tty", pCEnt->GetName()))
//		//{
//		//	char	szPrint[512] = "";
//
//		//	CMgrNode	*pCNode = pCEnt->m_pCMgrNodeHead;
//		//	while (pCNode)
//		//	{
//		//		sprintf(szPrint + strlen(szPrint), "[%d,%d],", pCNode->m_pCMgrUnit->m_sPosX, pCNode->m_pCMgrUnit->m_sPosY);
//		//		pCNode = pCNode->m_pCNext;
//		//	}
//		//	LG("移动轨迹", "向目标添加后，角色占用的单元：%s.\n", szPrint);
//
//		//	LG("移动轨迹", "目标范围被添加后，拥有的角色：\n");
//		//	for (y = l_dstTerr.ltop.y; y <= l_dstTerr.rbtm.y; y++)
//		//		for (x = l_dstTerr.ltop.x; x <= l_dstTerr.rbtm.x; x++)
//		//		{
//		//			szPrint[0] = '\0';
//		//			CEntityListNode	*pCNode = m_pCMgrUnit[y][x]->m_pCChaIn;
//		//			while (pCNode)
//		//			{
//		//				sprintf(szPrint + strlen(szPrint), "%s,", pCNode->m_pCEntity->m_CLog.GetLogName());
//		//				pCNode = pCNode->m_pCNext;
//		//			}
//		//			LG("移动轨迹", "\t中心链[%d,%d]：%s\n", x, y, szPrint);
//		//			szPrint[0] = '\0';
//		//			pCNode = m_pCMgrUnit[y][x]->m_pCChaCross;
//		//			while (pCNode)
//		//			{
//		//				sprintf(szPrint + strlen(szPrint), "%s,", pCNode->m_pCEntity->m_CLog.GetLogName());
//		//				pCNode = pCNode->m_pCNext;
//		//			}
//		//			LG("移动轨迹", "\t交叉链[%d,%d]：%s\n", x, y, szPrint);
//		//		}
//		//	LG("移动轨迹", "\n");
//		//}
//		////
//	}
//}
//
//=============================================================================
// 进入副本（如果成功，则更新视野单元，进行视野通告）
// bActiveMgr 是否会激活管理单元
//=============================================================================
bool SubMap::Enter(Square* pSEntShape, Entity* ent, cLong clSearchRadius) {
	T_B
		ent->SetInitShape(*pSEntShape);

	const Point l_pt = pSEntShape->centre;
	bool l_retval = true;
	Point l_pt2, l_pt1;

	l_pt1 = l_pt;
	Rect l_rect = GetEyeshot(l_pt1);
	long lStep = pSEntShape->radius;

	if (lStep == 0) // 对于自身半径为0的情况
		lStep = 40;

	//确定初始位置
	ent->m_submap = this;
	long l_xdlt = 0, l_ydlt = 0;

	if (clSearchRadius > 0) {
		if (ent->overlap(l_xdlt, l_ydlt)) {
			long l_dist = 0;
			bool l_overflag = true;
			while (l_overflag) //直到确定位置为止
			{
				l_dist++;
				for (short dir = 0; dir < 4; dir++) {
					l_pt1 = l_pt;
					//long l_radius	=2 * lStep * l_dist;
					long l_radius = GetBlockCellWidth() * l_dist;
					if (l_radius > clSearchRadius) {
						l_retval = false;
						l_overflag = false;
						break;
					}
					l_pt1.move(dir * 90, l_radius);
					l_pt2 = l_pt1;
					l_rect = GetEyeshot(l_pt2);

					ent->SetPos(l_pt1);
					l_xdlt = l_ydlt = 0;

					if (!(l_overflag = ent->overlap(l_xdlt, l_ydlt))) {
						l_retval = true;
						break;
					}
				}
			}
		}
	} else if (clSearchRadius == 0) {
		if (ent->overlap(l_xdlt, l_ydlt))
			l_retval = false;
	} else // 强制进入
	{
	}
	//beginsee
	if (l_retval) {
		bool bActive = ent->GetEyeshotAbility();

		for (long y = l_rect.ltop.y; y <= l_rect.rbtm.y; y++) {
			for (long x = l_rect.ltop.x; x <= l_rect.rbtm.x; x++) {
				if (bActive)
					ActiveEyeshotCell(x, y);

				m_pCEyeshotCell[y][x].EnterEyeshot(ent);
			}
		}

		//加入
		ent->RefreshArea();
		Add(ent);
		ent->m_lastpos = ent->GetPos();
	} else
		ent->m_submap = 0;

	return l_retval;
	T_E
}

// 模拟Enter例程，确定进入位置，但不执行进入副本操作
bool SubMap::EnsurePos(Square* pSEntShape, Entity* ent, cLong clSearchRadius) {
	T_B
		ent->SetInitShape(*pSEntShape);

	const Point l_pt = pSEntShape->centre;
	bool l_retval = true;
	Point l_pt2, l_pt1;

	l_pt1 = l_pt;
	long lStep = pSEntShape->radius;

	if (lStep == 0) // 对于自身半径为0的情况
		lStep = 40;

	//确定初始位置
	ent->m_submap = this;
	long l_xdlt = 0, l_ydlt = 0;

	if (clSearchRadius > 0) {
		if (ent->overlap(l_xdlt, l_ydlt)) {
			long l_dist = 0;
			bool l_overflag = true;
			while (l_overflag) //直到确定位置为止
			{
				l_dist++;
				for (short dir = 0; dir < 6; dir++) {
					l_pt1 = l_pt;
					long l_radius = 2 * lStep * l_dist;
					if (l_radius > clSearchRadius) {
						l_retval = false;
						l_overflag = false;
						break;
					}
					l_pt1.move(dir * 60, l_radius);
					l_pt2 = l_pt1;

					ent->SetPos(l_pt1);
					l_xdlt = l_ydlt = 0;

					if (!(l_overflag = ent->overlap(l_xdlt, l_ydlt))) {
						l_retval = true;
						break;
					}
				}
			}
		}
	} else if (clSearchRadius == 0) {
		if (ent->overlap(l_xdlt, l_ydlt))
			l_retval = false;
	} else // 强制进入
	{
	}
	//beginsee
	if (!l_retval)
		ent->m_submap = 0;

	return l_retval;
	T_E
}

//=============================================================================
// 出副本，脱离视野单元，进行视野通告
// bActiveMgr 是否对管理单元的计数产生影响
//=============================================================================
void SubMap::GoOut(Entity* ent) {
	T_B
		Point l_pt = ent->GetShape().centre;
	Rect l_rect = GetEyeshot(l_pt);
	//删除
	Delete(ent);
	//endsee

	bool bActive = ent->GetEyeshotAbility();

	for (long y = l_rect.ltop.y; y <= l_rect.rbtm.y; y++) {
		for (long x = l_rect.ltop.x; x <= l_rect.rbtm.x; x++) {
			if (bActive)
				InactiveEyeshotCell(x, y);

			m_pCEyeshotCell[y][x].OutEyeshot(ent);
		}
	}

	ent->m_submap = 0;
	T_E
}

// 视野内的所有视野单元进行视野刷新
void SubMap::RefreshEyeshot(Entity* pCEnt, bool bEyeshot, bool bHide, bool bShow) {
	Point l_pt = pCEnt->GetShape().centre;
	Rect l_rect = GetEyeshot(l_pt);

	for (long y = l_rect.ltop.y; y <= l_rect.rbtm.y; y++) {
		for (long x = l_rect.ltop.x; x <= l_rect.rbtm.x; x++) {
			m_pCEyeshotCell[y][x].RefreshEyeshot(pCEnt, bEyeshot, bHide, bShow);
		}
	}
}

Rect SubMap::GetEyeshot(Point& pt) const {
	T_B const Rect& m_area = GetRange();
	Rect l_rect;
	pt.x = (pt.x - m_area.ltop.x) / GetEyeshotCellWidth();
	pt.y = (pt.y - m_area.ltop.y) / GetEyeshotCellHeight();
	l_rect.ltop.x = max(pt.x - GetEyeshotWidth(), 0);
	l_rect.ltop.y = max(pt.y - GetEyeshotWidth(), 0);
	l_rect.rbtm.x = min(pt.x + GetEyeshotWidth(), GetEyeshotCellCol() - 1);
	l_rect.rbtm.y = min(pt.y + GetEyeshotWidth(), GetEyeshotCellLin() - 1);
	return l_rect;
	T_E
}

Rect SubMap::GetEyeshot(short sMgrUnitX, short sMgrUnitY) const {
	T_B
		Rect l_rect;

	l_rect.ltop.x = max(sMgrUnitX - GetEyeshotWidth(), 0);
	l_rect.ltop.y = max(sMgrUnitY - GetEyeshotWidth(), 0);
	l_rect.rbtm.x = min(sMgrUnitX + GetEyeshotWidth(), GetEyeshotCellCol() - 1);
	l_rect.rbtm.y = min(sMgrUnitY + GetEyeshotWidth(), GetEyeshotCellLin() - 1);

	return l_rect;
	T_E
}

void SubMap::GetEyeshotCenter(Point& pt) {
	T_B const Rect& m_area = GetRange();
	pt.x = (pt.x - m_area.ltop.x) / GetEyeshotCellWidth();
	pt.y = (pt.y - m_area.ltop.y) / GetEyeshotCellHeight();
	T_E
}

Rect SubMap::GetHoldStateCell(Point& pt, Long lRadius) const {
	T_B const Rect& m_area = GetRange();
	Rect l_rect;
	if (lRadius > 0) {
		l_rect.ltop.x = (pt.x - lRadius - m_area.ltop.x) / GetStateCellWidth();
		l_rect.ltop.y = (pt.y - lRadius - m_area.ltop.y) / GetStateCellHeight();
		l_rect.rbtm.x = (pt.x + lRadius - m_area.ltop.x) / GetStateCellWidth();
		l_rect.rbtm.y = (pt.y + lRadius - m_area.ltop.x) / GetStateCellHeight();

		if (l_rect.ltop.x < 0)
			l_rect.ltop.x = 0;
		if (l_rect.rbtm.x >= GetStateCellCol())
			l_rect.rbtm.x = GetStateCellCol() - 1;
		if (l_rect.ltop.y < 0)
			l_rect.ltop.y = 0;
		if (l_rect.rbtm.y >= GetStateCellLin())
			l_rect.rbtm.y = GetStateCellLin() - 1;
	} else {
		l_rect.ltop.x = pt.x / GetStateCellWidth();
		l_rect.ltop.y = pt.y / GetStateCellHeight();
		l_rect.rbtm.x = pt.x / GetStateCellWidth();
		l_rect.rbtm.y = pt.y / GetStateCellHeight();
	}
	pt.x = (pt.x - m_area.ltop.x) / GetStateCellWidth();
	pt.y = (pt.y - m_area.ltop.y) / GetStateCellHeight();

	return l_rect;
	T_E
}

void SubMap::GetHoldStateCellCenter(Point& pt) {
	const Rect& m_area = GetRange();
	pt.x = (pt.x - m_area.ltop.x) / GetStateCellWidth();
	pt.y = (pt.y - m_area.ltop.y) / GetStateCellHeight();
}

//===============Search===================================================================================
CCharacter* SubMap::FindCharacter(dbc::uLong ulID, const Point& point) {
	T_B
		CCharacter* pCha = NULL;
	Long lRangeB[] = {point.x, point.y, 0};
	Long lRangeE[] = {enumRANGE_TYPE_CIRCLE, 10 * 100};
	BeginSearchInRange(lRangeB, lRangeE);
	while (pCha = GetNextCharacterInRange()) {
		if (pCha->GetID() == ulID)
			break;
	}

	return pCha;
	T_E
}

//=============================================================================
// plRangeBParam 区域基本参数：个数 defSKILL_RANGE_BASEP_NUM， 内容 区域中心坐标，方向
// plRangeEParam 区域扩展参数：个数 defSKILL_RANGE_EXTEP_NUM， 内容 范围类型，类型参数
// bIncludeHideEnti 是否包含隐身的实体
//=============================================================================
void SubMap::BeginSearchInRange(Long* plRangeBParam, Long* plRangeEParam, bool bIncludeHideEnti) {
	T_B
		m_sRangeCurMgrUnit = -1;
	m_pRangeCurEntiNode = 0;
	m_bIncludeHideEnti = bIncludeHideEnti;

	Long lCx = plRangeBParam[0];
	Long lCy = plRangeBParam[1];
	Long lAngle = plRangeBParam[2];
	Long lRangeType = plRangeEParam[0];

	Long lUnitSX, lUnitEX, lUnitSY, lUnitEY;
	Long lMaxRadius;
	if (lRangeType == enumRANGE_TYPE_STICK) {
		Long lRadius = plRangeEParam[1];
		Long lWidth = plRangeEParam[2];

		m_pCBaseRange = &m_CStickRange;
		m_CStickRange.setPos(lCx, lCy);
		m_CStickRange.setAngle(lAngle);
		m_CStickRange.setRadius(lRadius);
		m_CStickRange.setWidth(lWidth);

		lMaxRadius = (Long)sqrt(double(lRadius * lRadius + (lWidth / 2) * (lWidth / 2)));
	} else if (lRangeType == enumRANGE_TYPE_FAN) {
		Long lRadius = plRangeEParam[1];
		Long lAngleD = plRangeEParam[2];

		m_pCBaseRange = &m_CFanRange;
		m_CFanRange.setPos(lCx, lCy);
		lAngle = lAngle - lAngleD / 2;
		if (lAngle < 0)
			lAngle += 360;
		m_CFanRange.setAngle(lAngle);
		m_CFanRange.setAngleStep(lAngleD);
		m_CFanRange.setRadius(lRadius);

		lMaxRadius = lRadius;
	} else if (lRangeType == enumRANGE_TYPE_SQUARE) {
		Long lRadius = plRangeEParam[1];

		m_pCBaseRange = &m_CSquareCRange;
		m_CSquareCRange.setPos(lCx, lCy);
		m_CSquareCRange.setAngle(lAngle);
		m_CSquareCRange.setRadius(lRadius);

		lMaxRadius = lRadius;
	} else if (lRangeType == enumRANGE_TYPE_CIRCLE) {
		Long lRadius = plRangeEParam[1];

		m_pCBaseRange = &m_CCircleRange;
		m_CCircleRange.setPos(lCx, lCy);
		m_CCircleRange.setRadius(lRadius);

		lMaxRadius = lRadius;
	} else
		m_pCBaseRange = 0;

	if (!m_pCBaseRange)
		return;

	m_lRangeCentUnit[0] = lCx / GetStateCellWidth();
	m_lRangeCentUnit[1] = lCy / GetStateCellHeight();

	lUnitSX = (lCx - lMaxRadius) / GetStateCellWidth();
	lUnitEX = (lCx + lMaxRadius) / GetStateCellWidth();
	lUnitSY = (lCy - lMaxRadius) / GetStateCellHeight();
	lUnitEY = (lCy + lMaxRadius) / GetStateCellHeight();
	lUnitSX = lUnitSX < 0 ? 0 : lUnitSX;
	lUnitEX = lUnitEX > GetStateCellCol() - 1 ? GetStateCellCol() - 1 : lUnitEX;
	lUnitSY = lUnitSY < 0 ? 0 : lUnitSY;
	lUnitEY = lUnitEY > GetStateCellLin() - 1 ? GetStateCellLin() - 1 : lUnitEY;

	m_sRangeMgrUnitNum = 0;
	Long sx, sy, ex, ey;
	for (int i = lUnitSY; i <= lUnitEY; i++)
		for (int j = lUnitSX; j <= lUnitEX; j++) {
			sx = j * GetStateCellWidth();
			ex = sx + GetStateCellWidth() - 1;
			sy = i * GetStateCellHeight();
			ey = sy + GetStateCellHeight() - 1;
			if (m_pCBaseRange->RectHitTest(sx, sy, ex, ey)) // 管理单元在范围内
			{
				m_lRangeMgrUnit[m_sRangeMgrUnitNum][0] = j;
				m_lRangeMgrUnit[m_sRangeMgrUnitNum][1] = i;
				m_sRangeMgrUnitNum++;
				if (m_sRangeMgrUnitNum >= defRANGE_MGRUNIU_NUM) {
					//MessageBox(NULL, "区域搜索的范围超过设定值", "错误", MB_OK);
					MessageBox(NULL, RES_STRING(GM_SUBMAP_CPP_00004), RES_STRING(GM_SUBMAP_CPP_00005), MB_OK);
					return;
				}
			}
		}
	T_E
}

CCharacter* SubMap::GetNextCharacterInRange(void) {
	T_B if (!m_pCBaseRange) return 0;

Research:
	if (m_pRangeCurEntiNode)
		m_pRangeCurEntiNode = m_pRangeCurEntiNode->m_pCNext;

	while (!m_pRangeCurEntiNode) {
		m_sRangeCurMgrUnit++;
		if (m_sRangeCurMgrUnit >= m_sRangeMgrUnitNum)
			return 0;
		if (m_pCStateCell[m_lRangeMgrUnit[m_sRangeCurMgrUnit][1]][m_lRangeMgrUnit[m_sRangeCurMgrUnit][0]])
			m_pRangeCurEntiNode = m_pCStateCell[m_lRangeMgrUnit[m_sRangeCurMgrUnit][1]][m_lRangeMgrUnit[m_sRangeCurMgrUnit][0]]->m_pCChaIn;
	}

	if (m_pRangeCurEntiNode) {
		if (!m_bIncludeHideEnti) {
			CCharacter* pCCha = m_pRangeCurEntiNode->m_pCCha;
			if (pCCha && pCCha->IsHide())
				goto Research;
			else
				return pCCha;
		} else
			return m_pRangeCurEntiNode->m_pCCha;
	} else
		return 0;
	T_E
}

//=============================================================================
// 在例程BeginSearchInRange设定的范围内增加状态
//=============================================================================
bool SubMap::RangeAddState(uChar uchFightID, uLong ulSrcWorldID, Long lSrcHandle,
						   Char chObjType, Char chObjHabitat, Char chEffType, Short* sStateParam) {
	T_B if (sStateParam[0] > AREA_STATE_MAXID || sStateParam[1] > SKILL_STATE_LEVEL) return false;

	if (!m_pCBaseRange)
		return false;

	CSkillStateRecord* pSStateR = 0;
	pSStateR = GetCSkillStateRecordInfo(sStateParam[0]);
	if (!pSStateR)
		return false;

	Long x, y;
	uLong ulStartTick = GetTickCount();
	bool bAddSuc;
	bool bAlreadyHas;
	for (Short i = 0; i < m_sRangeMgrUnitNum; i++) {
		bAddSuc = false;
		bAlreadyHas = false;
		x = m_lRangeMgrUnit[i][0], y = m_lRangeMgrUnit[i][1];

		if (m_pCStateCell[y][x] && m_pCStateCell[y][x]->m_CSkillState.HasState((uChar)sStateParam[0]))
			bAlreadyHas = true;
		if (x == m_lRangeCentUnit[0] && y == m_lRangeCentUnit[1])
			bAddSuc = AddCellState(uchFightID, ulSrcWorldID, lSrcHandle, chObjType, chObjHabitat, chEffType, x, y, (uChar)sStateParam[0], (uChar)sStateParam[1], ulStartTick, sStateParam[2], pSStateR->chAddType, 1);
		else
			bAddSuc = AddCellState(uchFightID, ulSrcWorldID, lSrcHandle, chObjType, chObjHabitat, chEffType, x, y, (uChar)sStateParam[0], (uChar)sStateParam[1], ulStartTick, sStateParam[2], pSStateR->chAddType, 0);
		if (!bAlreadyHas && bAddSuc) {
			NotiStateCellToEyeshot((short)x, (short)y);
		}
	}

	return true;
	T_E
}

bool SubMap::RangeAddState(Rect* pSRange, uChar uchFightID, uLong ulSrcWorldID, Long lSrcHandle,
						   Char chObjType, Char chObjHabitat, Char chEffType, Short* sStateParam) {
	T_B if (sStateParam[0] > AREA_STATE_MAXID || sStateParam[1] > SKILL_STATE_LEVEL) return false;

	CSkillStateRecord* pSStateR = 0;
	pSStateR = GetCSkillStateRecordInfo(sStateParam[0]);
	if (!pSStateR)
		return false;

	Long lUnitSX, lUnitEX, lUnitSY, lUnitEY, lUnitCX, lUnitCY;
	lUnitSX = pSRange->ltop.x / GetStateCellWidth();
	lUnitEX = pSRange->rbtm.x / GetStateCellWidth();
	lUnitSY = pSRange->ltop.y / GetStateCellHeight();
	lUnitEY = pSRange->rbtm.y / GetStateCellHeight();
	lUnitSX = lUnitSX < 0 ? 0 : lUnitSX;
	lUnitEX = lUnitEX > GetStateCellCol() - 1 ? GetStateCellCol() - 1 : lUnitEX;
	lUnitSY = lUnitSY < 0 ? 0 : lUnitSY;
	lUnitEY = lUnitEY > GetStateCellLin() - 1 ? GetStateCellLin() - 1 : lUnitEY;

	lUnitCX = lUnitSX + (lUnitEX - lUnitSX) / 2;
	lUnitCY = lUnitSY + (lUnitEY - lUnitSY) / 2;

	uLong ulStartTick = GetTickCount();
	bool bAddSuc;
	bool bAlreadyHas;
	for (Long y = lUnitSY; y <= lUnitEY; y++)
		for (Long x = lUnitSX; x <= lUnitEX; x++) {
			bAddSuc = false;
			bAlreadyHas = false;

			if (m_pCStateCell[y][x] && m_pCStateCell[y][x]->m_CSkillState.HasState((uChar)sStateParam[0]))
				bAlreadyHas = true;
			if (y == lUnitCY && x == lUnitCX)
				bAddSuc = AddCellState(uchFightID, ulSrcWorldID, lSrcHandle, chObjType, chObjHabitat, chEffType, x, y, (uChar)sStateParam[0], (uChar)sStateParam[1], ulStartTick, sStateParam[2], pSStateR->chAddType, 1);
			else
				bAddSuc = AddCellState(uchFightID, ulSrcWorldID, lSrcHandle, chObjType, chObjHabitat, chEffType, x, y, (uChar)sStateParam[0], (uChar)sStateParam[1], ulStartTick, sStateParam[2], pSStateR->chAddType, 0);
			if (!bAlreadyHas && bAddSuc) {
				ActiveEyeshotCell(m_pCStateCell[y][x]->m_pCEyeshotCell->m_sPosX, m_pCStateCell[y][x]->m_pCEyeshotCell->m_sPosY); // 状态激活管理单元
				NotiStateCellToEyeshot((short)x, (short)y);
			}
		}

	return true;
	T_E
}

void SubMap::NotiStateCellToEyeshot(Short sCellX, Short sCellY) {
	T_B if (!m_pCStateCell[sCellY][sCellX]) return;

	WPACKET pk = GETWPACKET();
	WRITE_CMD(pk, CMD_MC_ASTATEBEGINSEE);
	WRITE_SHORT(pk, sCellX);
	WRITE_SHORT(pk, sCellY);
	m_pCStateCell[sCellY][sCellX]->m_CSkillState.WriteState(pk);

	Rect l_rect = GetEyeshot(m_pCStateCell[sCellY][sCellX]->m_pCEyeshotCell->m_sPosX, m_pCStateCell[sCellY][sCellX]->m_pCEyeshotCell->m_sPosY);
	Entity* pCEnt;
	CCharacter* pCCha;
	CPlayer *pHeadPlayer = 0, *pLastPlayer = 0;
	for (long y = l_rect.ltop.y; y <= l_rect.rbtm.y; y++) {
		for (long x = l_rect.ltop.x; x <= l_rect.rbtm.x; x++) {
			pCEnt = m_pCEyeshotCell[y][x].m_pCChaL;
			while (pCEnt) {
				pCCha = pCEnt->IsCharacter();
				if (pCCha->IsPlayerFocusCha()) {
					if (!pHeadPlayer) {
						pHeadPlayer = pCCha->GetPlayer();
						pLastPlayer = pHeadPlayer;
					} else {
						pLastPlayer->GetNextPlayer() = pCCha->GetPlayer();
						pLastPlayer = (CPlayer*)pLastPlayer->GetNextPlayer();
					}
				}
				pCEnt = pCEnt->m_pCEyeshotCellNext;
			}
		}
	}
	if (pLastPlayer)
		pLastPlayer->GetNextPlayer() = NULL;
	SENDTOCLIENT(pk, pHeadPlayer);
	T_E
}

//=============================================================================
// 移动（移动位置，视野）
//=============================================================================
void SubMap::MoveTo(Entity* pCEnt, const Point& STar) {
	T_B if (pCEnt->GetPos() != pCEnt->m_lastpos) {
		Char szMess[512];
		//sprintf(szMess, "角色 %s 移动原始坐标错误，上次位置[%d, %d]，当前位置[%d, %d]，目标位置[%d, %d]",
		sprintf(szMess, "character %s move originality coordinate error，last time position[%d, %d]，current position[%d, %d]，aim position[%d, %d]",
				pCEnt->m_CLog.GetLogName(), pCEnt->m_lastpos.x, pCEnt->m_lastpos.y, pCEnt->GetPos().x, pCEnt->GetPos().y, STar.x, STar.y);
		//::MessageBox(0,szMess,"请调试!",MB_OK);
		//LG("移动错误", "%s\n", szMess);
		LG("move error", "%s\n", szMess);
		pCEnt->SetPos(pCEnt->m_lastpos);
	}
	Point l_src = pCEnt->GetPos();
	Point l_dst = STar;
	Point SrcPos = l_src;
	const Rect l_srcEyeshot = GetEyeshot(l_src);
	const Rect l_dstEyeshot = GetEyeshot(l_dst);

	MPTimer tMoveState, tMoveMMask, tMoveEyeshot, tMoveArea;
	tMoveState.Begin();
	MoveInStateCell(pCEnt->IsCharacter(), pCEnt->GetPos(), STar);
	tMoveState.End();
	tMoveMMask.Begin();
	MoveInMapMask(pCEnt->IsCharacter(), pCEnt->GetPos(), STar);
	tMoveMMask.End();
	tMoveEyeshot.Begin();
	pCEnt->SetPos(STar);
	if (l_src != l_dst) // 视角不重叠
	{
		//从源删除
		if (!pCEnt->m_pCEyeshotHost) {
			//LG("地图角色操作错误", "（移动）地图 %s 从视野单元[%d, %d]删除实体 %s 时，发现不在视野单元中\n", GetName(), l_src.x, l_src.y, pCEnt->GetLogName());
			LG("map character operator error", "(move)map  %s from eyeshot cell[%d, %d]delete entity %s ，find it isn't in the eyeshot cell.\n", GetName(), l_src.x, l_src.y, pCEnt->GetLogName());
			return;
		}
		if (pCEnt->m_pCEyeshotHost != &m_pCEyeshotCell[l_src.y][l_src.x]) {
			//LG("地图角色操作错误", "（移动）地图 %s 从视野单元[%d, %d]删除实体 %s 时，发现其与记录视野单元[%d, %d]不符\n", GetName(), l_src.x, l_src.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
			LG("map character operator error", "(move)map %s from eyeshot cell[%d, %d]delete entity %s ,find it isn't agree with log eyeshot cell[%d, %d].\n", GetName(), l_src.x, l_src.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
			return;
		}
		pCEnt->m_pCEyeshotHost = 0;
		m_pCEyeshotCell[l_src.y][l_src.x].DelEntity(pCEnt);

		bool bActive = pCEnt->GetEyeshotAbility();

		////beginsee and endsee
		//long	lXDist, lYDist, lXStep, lYStep, lSrcXStart, lTarXStart, lSrcYStart, lTarYStart;
		//lXDist = abs(l_src.x - l_dst.x);
		//if (lXDist > GetEyeshotWidth() * 2 + 1)
		//	lXDist = GetEyeshotWidth() * 2 + 1;
		//if (lXDist > 0)
		//{
		//	if (l_src.x >= l_dst.x)
		//	{
		//		if (l_srcEyeshot.rbtm.x == GetEyeshotCellCol() - 1)
		//			lSrcXStart = l_src.x + GetEyeshotWidth() - lXDist + 1;
		//		else
		//			lSrcXStart = l_srcEyeshot.rbtm.x - lXDist + 1;
		//		if (l_dstEyeshot.ltop.x == 0)
		//			lTarXStart = l_dst.x - GetEyeshotWidth();
		//		else
		//			lTarXStart = l_dstEyeshot.ltop.x;
		//	}
		//	else
		//	{
		//		if (l_srcEyeshot.ltop.x == 0)
		//			lSrcXStart = l_src.x - GetEyeshotWidth();
		//		else
		//			lSrcXStart = l_srcEyeshot.ltop.x;
		//		if (l_dstEyeshot.rbtm.x == GetEyeshotCellCol() - 1)
		//			lTarXStart = l_dst.x + GetEyeshotWidth() - lXDist + 1;
		//		else
		//			lTarXStart = l_dstEyeshot.rbtm.x - lXDist + 1;
		//	}

		//	for (long x = 0; x < lXDist; x++)
		//	{
		//		lXStep = lSrcXStart + x;
		//		if ((lXStep >= 0) && (lXStep <= GetEyeshotCellCol() - 1))
		//		{
		//			for (long y = l_srcEyeshot.ltop.y; y <= l_srcEyeshot.rbtm.y; y++)
		//			{
		//				if (bActive)
		//					InactiveEyeshotCell(lXStep, y);
		//				m_pCEyeshotCell[y][lXStep].OutEyeshot(pCEnt);
		//			}
		//		}
		//		lXStep = lTarXStart + x;
		//		if ((lXStep >= 0) && (lXStep <= GetEyeshotCellCol() - 1))
		//		{
		//			for (long y = l_dstEyeshot.ltop.y; y <= l_dstEyeshot.rbtm.y; y++)
		//			{
		//				if (bActive)
		//					ActiveEyeshotCell(lXStep, y);
		//				m_pCEyeshotCell[y][lXStep].EnterEyeshot(pCEnt);
		//			}
		//		}
		//	}
		//}

		//lXDist = abs(l_src.x - l_dst.x);
		//lYDist = abs(l_src.y - l_dst.y);
		//if ((lYDist > 0) && (lXDist < GetEyeshotWidth() * 2 + 1))
		//{
		//	lXDist = GetEyeshotWidth() * 2 + 1 - lXDist;
		//	if (l_src.x >= l_dst.x)
		//	{
		//		if (l_srcEyeshot.ltop.x == 0)
		//		{
		//			lSrcXStart = 0;
		//			lXDist += l_src.x - GetEyeshotWidth();
		//		}
		//		else
		//			lSrcXStart = l_srcEyeshot.ltop.x;
		//	}
		//	else
		//	{
		//		if (l_dstEyeshot.ltop.x == 0)
		//		{
		//			lSrcXStart = 0;
		//			lXDist += l_dst.x - GetEyeshotWidth();
		//		}
		//		else
		//			lSrcXStart = l_dstEyeshot.ltop.x;
		//	}
		//	if (lYDist > GetEyeshotWidth() * 2 + 1)
		//		lYDist = GetEyeshotWidth() * 2 + 1;
		//	if (l_src.y >= l_dst.y)
		//	{
		//		if (l_srcEyeshot.rbtm.y == GetEyeshotCellLin() - 1)
		//			lSrcYStart = l_src.y + GetEyeshotWidth() - lYDist + 1;
		//		else
		//			lSrcYStart = l_srcEyeshot.rbtm.y - lYDist + 1;
		//		if (l_dstEyeshot.ltop.y == 0)
		//			lTarYStart = l_dst.y - GetEyeshotWidth();
		//		else
		//			lTarYStart = l_dstEyeshot.ltop.y;
		//	}
		//	else
		//	{
		//		if (l_srcEyeshot.ltop.y == 0)
		//			lSrcYStart = l_src.y - GetEyeshotWidth();
		//		else
		//			lSrcYStart = l_srcEyeshot.ltop.y;
		//		if (l_dstEyeshot.rbtm.y == GetEyeshotCellLin() - 1)
		//			lTarYStart = l_dst.y + GetEyeshotWidth() - lYDist + 1;
		//		else
		//			lTarYStart = l_dstEyeshot.rbtm.y - lYDist + 1;
		//	}
		//	for (long x = 0; x < lXDist; x++)
		//	{
		//		lXStep = lSrcXStart + x;
		//		for (long y = 0; y < lYDist; y++)
		//		{
		//			lYStep = lSrcYStart + y;
		//			if ((lYStep >= 0) && (lYStep <= GetEyeshotCellLin() - 1))
		//			{
		//				if (bActive)
		//					InactiveEyeshotCell(lXStep, lYStep);
		//				m_pCEyeshotCell[lYStep][lXStep].OutEyeshot(pCEnt);
		//			}

		//			lYStep = lTarYStart + y;
		//			if ((lYStep >= 0) && (lYStep <= GetEyeshotCellLin() - 1))
		//			{
		//				if (bActive)
		//					ActiveEyeshotCell(lXStep, lYStep);
		//				m_pCEyeshotCell[lYStep][lXStep].EnterEyeshot(pCEnt);
		//			}
		//		}
		//	}
		//}

		const long l_xmin = min(l_srcEyeshot.ltop.x, l_dstEyeshot.ltop.x);
		const long l_xmax = max(l_srcEyeshot.rbtm.x, l_dstEyeshot.rbtm.x);
		const long l_ymin = min(l_srcEyeshot.ltop.y, l_dstEyeshot.ltop.y);
		const long l_ymax = max(l_srcEyeshot.rbtm.y, l_dstEyeshot.rbtm.y);
		for (long y = l_ymin; y <= l_ymax; y++) {
			for (long x = l_xmin; x <= l_xmax; x++) {
				const long l_srcx = abs(x - l_src.x);
				const long l_srcy = abs(y - l_src.y);
				const long l_dstx = abs(x - l_dst.x);
				const long l_dsty = abs(y - l_dst.y);
				if (l_srcx <= GetEyeshotWidth() && l_srcy <= GetEyeshotWidth() && l_dstx <= GetEyeshotWidth() && l_dsty <= GetEyeshotWidth()) //相交区域
					continue;
				else if ((l_srcx > GetEyeshotWidth() || l_srcy > GetEyeshotWidth()) && (l_dstx > GetEyeshotWidth() || l_dsty > GetEyeshotWidth())) //无关区域
					continue;
				else if (abs(x - l_src.x) <= GetEyeshotWidth() && abs(y - l_src.y) <= GetEyeshotWidth()) //源块附近的，endsee
				{
					if (bActive)
						InactiveEyeshotCell(x, y);
					m_pCEyeshotCell[y][x].OutEyeshot(pCEnt);
				} else //目标块附近的，beginsee
				{
					if (bActive)
						ActiveEyeshotCell(x, y);
					m_pCEyeshotCell[y][x].EnterEyeshot(pCEnt);
				}
			}
		}

		//插入目标
		if (pCEnt->m_pCEyeshotHost) {
			//LG("地图角色操作错误", "（移动）地图 %s 向视野单元[%d, %d]增加实体 %s 时，发现其没有脱离先前的视野单元[%d, %d]\n", GetName(), l_dst.x, l_dst.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
			LG("map character operator error", "(move)map %s from eyeshot cell[%d, %d] add entity %s ，find it is not break away foregone manage cell[%d, %d]\n", GetName(), l_dst.x, l_dst.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
			return;
		}
		pCEnt->m_pCEyeshotHost = &m_pCEyeshotCell[l_dst.y][l_dst.x];
		m_pCEyeshotCell[l_dst.y][l_dst.x].AddEntity(pCEnt->IsCharacter());
	}
	tMoveEyeshot.End();

	tMoveArea.Begin();
	pCEnt->RefreshArea(&SrcPos);
	pCEnt->m_lastpos = STar;
	tMoveArea.End();

	DWORD dwAllTime = tMoveState.GetTimeCount() + tMoveMMask.GetTimeCount() + tMoveEyeshot.GetTimeCount() + tMoveArea.GetTimeCount();
	if (dwAllTime >= 50)
		//LG("map_time", "\t\t角色[%s]视野移动花费的时间过长 time = %u（其中状态花费%u，探索度花费%u，视野花费%u，区域花费%u）\n",
		LG("map_time", "\t\tcharacter[%s] eyeshot move spend overabundance time time = %u（thereinto state spend %u，explore spend %u，eyeshot spend %u，area spend %u）\n",
		   pCEnt->GetLogName(), dwAllTime, tMoveState.GetTimeCount(), tMoveMMask.GetTimeCount(), tMoveEyeshot.GetTimeCount(), tMoveArea.GetTimeCount());
	T_E
}

void SubMap::LoadMonsterInfo(void) { T_B
										 T_E }

// 重置地表状态
void SubMap::ClearSurfaceState(void) {
	T_B
		CStateCell* pCStateCell;
	m_CStateCellL.BeginGet();
	while (pCStateCell = m_CStateCellL.GetNext()) {
		pCStateCell->DropState(this);
	}
	T_E
}

// 复位非玩家角色，用于副本重新开启时的角色初始化
void SubMap::ResetNotPlyCha() {
	T_B
		CCharacter* pCCha;
	Long lChaCount, lChaNum;
	CEyeshotCell* pCEyeCell;
	for (Short y = 0; y < GetEyeshotCellLin(); y++) {
		for (Short x = 0; x < GetEyeshotCellCol(); x++) {
			pCEyeCell = &m_pCEyeshotCell[y][x];
			lChaCount = 0;
			lChaNum = pCEyeCell->GetChaNum();
			pCCha = pCEyeCell->m_pCChaL;

			while (pCCha) {
				if (++lChaCount > lChaNum) {
					//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					LG("eyeshot activation error", "eyeshot cell[%d,%d] practice entity numbers%d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					break;
				}

				if (!pCCha->IsPlayerOwnCha())
					pCCha->Reset();

				if (pCCha->m_pCEyeshotCellNext)
					pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
				else
					pCCha = 0;
			}
		}
	}
	T_E
}

// 驱除玩家角色，用于副本关闭时，所有玩家角色出副本
void SubMap::ClearPlayerCha() {
	T_B
		CEyeshotCell* pCEyeCell;
	CCharacter *pCCha, *pCProcCha;
	long lChaCount, lChaNum;
	//LG("enter_map", "地图 %s（副本号 %d），开始清除所有玩家!\n", GetName(), GetCopyNO());
	LG("enter_map", "map %s(copyID %d),start delete all character!\n", GetName(), GetCopyNO());
	m_CEyeshotCellL.BeginGet();
	while (pCEyeCell = m_CEyeshotCellL.GetNext()) {
		lChaCount = 0;
		lChaNum = pCEyeCell->GetChaNum();
		pCCha = pCEyeCell->m_pCChaL;
		while (pCCha) {
			if (++lChaCount > lChaNum) {
				//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				LG("eyeshot activation error", "eyeshot cell[%d,%d]practice entity numbers %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				break;
			}

			pCProcCha = pCCha;
			if (pCCha->m_pCEyeshotCellNext)
				pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
			else
				pCCha = 0;

			if (pCProcCha->IsPlayerFocusCha()) {
				if (!pCProcCha->GetSubMap())
					//LG("视野激活错误", "在进行地图通告时玩家 %s(%s)[%d,%d] 的地图为空\n",
					LG("eyeshot activation error", "in the wind map notify character %s(%s)[%d,%d] 's map is empty\n",
					   pCProcCha->GetLogName(), pCProcCha->GetPlyCtrlCha()->GetLogName(), pCProcCha->GetPos().x, pCProcCha->GetPos().y);

				//LG("enter_map", "地图 %s 关闭，清除玩家 %s[%s]!\n", GetName(), pCProcCha->GetName(), pCProcCha->GetPlyMainCha()->GetName());
				LG("enter_map", "map %s close，clean out %s[%s]!\n", GetName(), pCProcCha->GetName(), pCProcCha->GetPlyMainCha()->GetName());
				if (!pCProcCha->IsLiveing()) {
					g_CParser.DoString("Relive", enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, pCProcCha, DOSTRING_PARAM_END);

					pCProcCha->m_chSelRelive = enumEPLAYER_RELIVE_NONE;
					pCProcCha->m_chReliveLv = 0;
					pCProcCha->BackToCityEx(true);
				} else
					pCProcCha->BackToCityEx();
			}
		}
	}
	m_COutMapCha.Drop();
	//LG("enter_map", "地图 %s（副本号 %d） 清除玩家成功!\n", GetName(), GetCopyNO());
	LG("enter_map", "map %s( copyID %d)clean out character succeed!\n", GetName(), GetCopyNO());
	T_E
}

void SubMap::ClearAllMonster(void) {
	T_B
		CCharacter* pCCha;
	Long lChaCount, lChaNum;
	CEyeshotCell* pCEyeCell;
	for (Short y = 0; y < GetEyeshotCellLin(); y++) {
		for (Short x = 0; x < GetEyeshotCellCol(); x++) {
			pCEyeCell = &m_pCEyeshotCell[y][x];
			lChaCount = 0;
			lChaNum = pCEyeCell->GetChaNum();
			pCCha = pCEyeCell->m_pCChaL;

			while (pCCha) {
				if (++lChaCount > lChaNum) {
					//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					LG("eyeshot activation error", "eyeshot cell[%d,%d]practice entity number %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					break;
				}

				if (!pCCha->IsPlayerOwnCha())
					pCCha->ResetLifeTime(1000);

				if (pCCha->m_pCEyeshotCellNext)
					pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
				else
					pCCha = 0;
			}
		}
	}
	T_E
}

void SubMap::ClearAllMonsterByName(const char* szMonsName) {
	T_B
		CCharacter* pCCha;
	Long lChaCount, lChaNum;
	CEyeshotCell* pCEyeCell;
	for (Short y = 0; y < GetEyeshotCellLin(); y++) {
		for (Short x = 0; x < GetEyeshotCellCol(); x++) {
			pCEyeCell = &m_pCEyeshotCell[y][x];
			lChaCount = 0;
			lChaNum = pCEyeCell->GetChaNum();
			pCCha = pCEyeCell->m_pCChaL;

			while (pCCha) {
				if (++lChaCount > lChaNum) {
					//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					LG("eyeshot activation error", "eyeshot cell[%d,%d]practice entity number %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					break;
				}

				if (!pCCha->IsPlayerOwnCha()) {
					if (!strcmp(pCCha->GetName(), szMonsName))
						pCCha->ResetLifeTime(1000);
				}

				if (pCCha->m_pCEyeshotCellNext)
					pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
				else
					pCCha = 0;
			}
		}
	}
	T_E
}

void SubMap::ClearAllCha() {
	T_B
		CEyeshotCell* pCEyeCell;
	CCharacter *pCCha, *pCProcCha;
	long lChaCount, lChaNum;
	//LG("enter_map", "地图 %s（副本号 %d），开始清除所有怪物!\n", GetName(), GetCopyNO());
	LG("enter_map", "map %s(copyID %d)，start clean out all monsters\n", GetName(), GetCopyNO());
	m_CEyeshotCellL.BeginGet();
	while (pCEyeCell = m_CEyeshotCellL.GetNext()) {
		lChaCount = 0;
		lChaNum = pCEyeCell->GetChaNum();
		pCCha = pCEyeCell->m_pCChaL;
		while (pCCha) {
			if (++lChaCount > lChaNum) {
				//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				LG("eyeshot activation error", "eyeshot cell[%d,%d]practice entity numbers %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				break;
			}

			pCProcCha = pCCha;
			if (pCCha->m_pCEyeshotCellNext)
				pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
			else
				pCCha = 0;

			if (!pCProcCha->IsPlayerFocusCha()) {
				pCProcCha->Free();
			} else {
				if (!pCProcCha->GetSubMap())
					//LG("视野激活错误", "在进行地图通告时玩家 %s(%s)[%d,%d] 的地图为空\n",
					LG("eyeshot activation error", "in the wind map notify character %s(%s)[%d,%d] 's map is empty\n",
					   pCProcCha->GetLogName(), pCProcCha->GetPlyCtrlCha()->GetLogName(), pCProcCha->GetPos().x, pCProcCha->GetPos().y);

				//LG("enter_map", "地图 %s 关闭，清除玩家 %s[%s]!\n", GetName(), pCProcCha->GetName(), pCProcCha->GetPlyMainCha()->GetName());
				LG("enter_map", "map %s close,clean out character %s[%s]!\n", GetName(), pCProcCha->GetName(), pCProcCha->GetPlyMainCha()->GetName());
				if (!pCProcCha->IsLiveing()) {
					g_CParser.DoString("Relive", enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, pCProcCha, DOSTRING_PARAM_END);

					pCProcCha->m_chSelRelive = enumEPLAYER_RELIVE_NONE;
					pCProcCha->m_chReliveLv = 0;
					pCProcCha->BackToCityEx(true);
				} else
					pCProcCha->BackToCityEx();
			}
		}
		pCEyeCell->m_pCChaL = NULL;
	}
	//LG("enter_map", "地图 %s（副本号 %d） 清除怪物成功!\n", GetName(), GetCopyNO());
	LG("enter_map", "map %s(copyID %d)clean out monster succeed!\n", GetName(), GetCopyNO());
	T_E
}

void SubMap::EntryOpen() {
	T_B
	Open();
	T_E
}

void SubMap::EntryClose() { T_B
								T_E }

void SubMap::Open() {
	T_B if (m_bIsRun) return;

	m_bIsRun = true;
	T_E
}

void SubMap::Run(DWORD dwCurTime) {
	T_B if (!m_bIsRun) return;

	m_COutMapCha.Run(dwCurTime);

	if (m_timeScriptRun.IsOK(dwCurTime)) {
		string strScript = "map_copy_run_";
		strScript += GetName();
		g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);
	}

	if (m_timeSpecialRun.IsOK(dwCurTime)) {
		string strScript = "map_copy_run_special_";
		strScript += GetName();
		g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);
	}

	T_E
}

void SubMap::Close() {
	T_B if (!m_bIsRun) return;
	string strScript = "map_copy_before_close_";
	strScript += GetName();
	g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);

	ClearSurfaceState();

	ClearPlayerCha();
	m_COutMapCha.Drop();
	ResetNotPlyCha();

	strScript = "map_copy_close_";
	strScript += GetName();
	g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);

	m_bIsRun = false;
	T_E
}

void SubMap::BeforePlyOutMap(CCharacter* pCCha) {
	T_B
		m_pCMapRes->SubEntryPlayer(GetCopyNO());

	string strScript = "before_leave_";
	strScript += GetName();
	g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 2, pCCha, this, DOSTRING_PARAM_END);

	g_CParser.DoString("BeforeLeaveMap", enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, pCCha, DOSTRING_PARAM_END);

	T_E
}

void SubMap::AfterPlyEnterMap(CCharacter* pCCha) {
	T_B
		string strScript = "after_enter_";
	strScript += GetName();
	g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 2, pCCha, this, DOSTRING_PARAM_END);

	g_CParser.DoString("AfterEnterMap", enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, pCCha, DOSTRING_PARAM_END);
	T_E
}

void SubMap::BeginGetPlyCha(void) {
	T_B
		m_CEyeshotCellL.BeginGet();
	CEyeshotCell* pCEyeCell = m_CEyeshotCellL.GetCurrent();
	if (pCEyeCell)
		pCEyeCell->BeginGetCha();
	T_E
}

CCharacter* SubMap::GetNextPlyCha(void) {
	T_B
		CCharacter* pCCha = 0;

Research:
	CEyeshotCell* pCEyeCell = m_CEyeshotCellL.GetCurrent();
	if (pCEyeCell) {
		pCCha = pCEyeCell->GetNextCha();
		while (!pCCha) {
			m_CEyeshotCellL.GetNext();
			pCEyeCell = m_CEyeshotCellL.GetCurrent();
			if (!pCEyeCell)
				break;
			pCEyeCell->BeginGetCha();
			pCCha = pCEyeCell->GetNextCha();
		}
	}
	if (pCCha)
		if (!pCCha->IsPlayerOwnCha())
			goto Research;

	return pCCha;
	T_E
}

bool SubMap::CheckRun(void) {
	T_B if (IsRun()) return true;
	if (!m_pCMapRes)
		return false;

	if (m_pCMapRes->GetCopyStartType() == enumMAPCOPY_START_CONDITION) {
		if (m_pCMapRes->GetCopyStartCdtType() == enumMAPCOPY_START_CDT_PLYNUM) {
			if (GetPlayerNum() >= m_pCMapRes->GetCopyStartCdtVal()) {
				Open();

				string strScript = "map_copy_first_run_";
				strScript += GetName();
				g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);

				return true;
			}
		}
	}

	return false;
	T_E
}

void SubMap::DealActivePlayer(string& function) {
	T_B
		CCharacter* pCha;
	BeginGetPlyCha();

	while (pCha = GetNextPlyCha()) {
		if (pCha->IsPlayerCha() && pCha->IsLiveing()) {
			g_CParser.DoString(function.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, pCha, DOSTRING_PARAM_END);
		}
	}

	T_E
}

void SubMap::DealPlayer(string& function) {
	T_B
		CCharacter* pCha = NULL;
	BeginGetPlyCha();

	while (pCha = GetNextPlyCha()) {
		if (pCha->IsPlayerCha()) {
			g_CParser.DoString(function.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, pCha, DOSTRING_PARAM_END);
		}
	}
	T_E
}

//=============================================================================
COutMapCha::COutMapCha(unsigned short usFreq) {
	T_B
		m_ulTick = GetTickCount();
	m_usFreq = usFreq;
	m_pSExecQueue = NULL;
	m_pSFreeQueue = NULL;
	T_E
}

COutMapCha::~COutMapCha() {
	T_B
		SMgrUnit* pSCarrier;

	pSCarrier = m_pSExecQueue;
	while (pSCarrier) {
		m_pSExecQueue = pSCarrier->pSNext;
		delete pSCarrier;
		pSCarrier = m_pSExecQueue;
	}

	pSCarrier = m_pSFreeQueue;
	while (pSCarrier) {
		m_pSFreeQueue = pSCarrier->pSNext;
		delete pSCarrier;
		pSCarrier = m_pSFreeQueue;
	}
	T_E
}

void COutMapCha::Add(CCharacter* pCObj, dbc::uLong ulChaID, SSwitchMapInfo* pSwitchInfo, Char chAction, Long lLeftTick1, Long lLeftTick2) {
	T_B if (!pCObj) return;

	SMgrUnit* pSCarrier = NULL;

	if (m_pSFreeQueue) // 有空闲的载体
	{
		pSCarrier = m_pSFreeQueue;
		m_pSFreeQueue = pSCarrier->pSNext;
	} else // 分配新的载体
	{
		pSCarrier = new SMgrUnit;
		if (!pSCarrier) {
			//THROW_EXCP(excpMem, "区域状态管理对象构造过程中分配内存失败");
			THROW_EXCP(excpMem, RES_STRING(GM_SUBMAP_CPP_00006));
		}
	}

	// 设置数据并将之加入执行队列
	pSCarrier->pCCha = pCObj;
	pSCarrier->ulChaID = ulChaID;
	memcpy(&pSCarrier->SwitchInfo, pSwitchInfo, sizeof(SSwitchMapInfo));
	pSCarrier->chAction = chAction;
	pSCarrier->lLeftTick1 = lLeftTick1;
	pSCarrier->lLeftTick2 = lLeftTick2;
	pSCarrier->chStep = 1;

	pSCarrier->pSNext = m_pSExecQueue;
	m_pSExecQueue = pSCarrier;
	T_E
}

void COutMapCha::Run(unsigned long ulCurTick) {
	T_B long lTickDist = ulCurTick - m_ulTick;

	if (lTickDist < m_usFreq)
		return;
	m_ulTick = ulCurTick;

	bool bDrop;
	SMgrUnit *pSCarrier, *pSLastCarrier;
	pSCarrier = pSLastCarrier = m_pSExecQueue;
	while (pSCarrier) {
		if (!pSCarrier->IsValidCha()) // 角色已经无效
		{
			// 从执行队列中脱链
			if (pSCarrier == m_pSExecQueue) {
				m_pSExecQueue = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSLastCarrier = m_pSExecQueue;
				pSCarrier = pSLastCarrier;
			} else {
				pSLastCarrier->pSNext = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSCarrier = pSLastCarrier->pSNext;
			}
			continue;
		}

		bDrop = false;

		if (pSCarrier->chStep == 1) {
			pSCarrier->lLeftTick1 -= lTickDist;
			if (pSCarrier->lLeftTick1 <= 0)
				ExecTimeCha(pSCarrier);
		} else if (pSCarrier->chStep == 2) {
			pSCarrier->lLeftTick2 -= lTickDist;
			if (pSCarrier->lLeftTick2 <= 0)
				bDrop = true;
		}

		if (!bDrop) {
			pSLastCarrier = pSCarrier;
			pSCarrier = pSCarrier->pSNext;
		} else // 载体的计时完成
		{
			ExecTimeCha(pSCarrier);
			// 从执行队列中脱链
			if (pSCarrier == m_pSExecQueue) {
				m_pSExecQueue = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSLastCarrier = m_pSExecQueue;
				pSCarrier = pSLastCarrier;
			} else {
				pSLastCarrier->pSNext = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSCarrier = pSLastCarrier->pSNext;
			}
		}
	}
	T_E
}

void COutMapCha::Drop() {
	T_B
		SMgrUnit *pSCarrier,
		*pSLastCarrier;
	pSCarrier = pSLastCarrier = m_pSExecQueue;
	while (pSCarrier) {
		// 载体的计时完成
		{
			ExecTimeCha(pSCarrier);
			ExecTimeCha(pSCarrier);
			// 从执行队列中脱链
			if (pSCarrier == m_pSExecQueue) {
				m_pSExecQueue = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSLastCarrier = m_pSExecQueue;
				pSCarrier = pSLastCarrier;
			} else {
				pSLastCarrier->pSNext = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSCarrier = pSLastCarrier->pSNext;
			}
		}
	}
	T_E
}

void COutMapCha::ExecTimeCha(SMgrUnit* pChaInfo) {
	T_B if (pChaInfo->chStep == 1) {
		pChaInfo->SwitchInfo.pSrcMap->GoOut(pChaInfo->pCCha);
		pChaInfo->pCCha->SetExistState(enumEXISTS_RESUMEING);
		pChaInfo->chStep++;
	}
	else if (pChaInfo->chStep == 2) {
		switch (pChaInfo->chAction) {
		case enumCHA_TIMEER_ENTERMAP: {
			CCharacter* pCCha = pChaInfo->pCCha;
			if (pCCha->IsPlayerCha()) // 不应该出现的情况
			{
				//LG("怪物重生错误", "怪物名称 %s，玩家角色名称 %s(%s)\n", pCCha->GetLogName(), pCCha->GetPlyMainCha()->GetLogName(), pCCha->GetPlyCtrlCha()->GetLogName());
				LG("monster renascence errror", "monster name %s，character player name %s(%s)\n", pCCha->GetLogName(), pCCha->GetPlyMainCha()->GetLogName(), pCCha->GetPlyCtrlCha()->GetLogName());
				break;
			}

			// 非玩家角色如果设置了生命时间, 则不会重生
			if (pCCha->GetLifeTime() != 0) {
				break;
			}

			pCCha->SetInOutMapQueue(false);
			pCCha->m_chSelRelive = enumEPLAYER_RELIVE_NONE;

			g_ulCurID = pCCha->GetID();
			g_lCurHandle = pCCha->GetHandle();

			pCCha->setAttr(ATTR_HP, pCCha->m_CChaAttr.GetAttr(ATTR_MXHP)); // 当前HP
			pCCha->setAttr(ATTR_SP, pCCha->m_CChaAttr.GetAttr(ATTR_MXSP)); // 当前SP
			//pCCha->m_timerScripts.Reset();
			pCCha->SetExistState(enumEXISTS_NATALITY);
			pCCha->SwitchMap(pChaInfo->SwitchInfo.pSrcMap, pChaInfo->SwitchInfo.szTarMapName, pChaInfo->SwitchInfo.STarPos.x, pChaInfo->SwitchInfo.STarPos.y, false, enumSWITCHMAP_DIE, pChaInfo->SwitchInfo.pSrcMap->GetCopyNO());

			pCCha->ResetAIState(); // 重设ai所需的状态记录

			g_ulCurID = defINVALID_CHA_ID;
			g_lCurHandle = defINVALID_CHA_HANDLE;
		} break;
		}
		pChaInfo->chStep++;
	}
	T_E
}
